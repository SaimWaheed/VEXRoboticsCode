#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  fourBarEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  chainBarEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           leftDirect,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftNonDirect, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           rightDirect,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl3)
#pragma config(Motor,  port5,           rightNonDirect, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port6,           mobileGoal,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           fourBar,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           chainBar,      tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma platform(VEX2)
#include "VEX_competition_Includes.c"

void driveStraightDistance(int ticks, int masterPower)
{
  //int tickGoal = (42 * tenthsOfIn) / 10;
 int tickGoal = ticks;

  //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  int totalTicks = 0;

  //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
  //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
  //veering off course at the start of the function.
  int slavePower = masterPower - 5;

  int error = 0;

  int kp = 5;

  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

  //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  while(abs(totalTicks) < tickGoal)
  {
    //Proportional algorithm to keep the robot going straight.
  	motor[rightNonDirect] = motor[rightDirect] = masterPower;
	motor[leftNonDirect] = motor[leftDirect] = slavePower;

    error = SensorValue[encoderLeft] - SensorValue[encoderRight];

    slavePower += error / kp;


  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

    wait1Msec(100);

    //Add this iteration's encoder values to totalTicks.
    totalTicks+= SensorValue[encoderLeft];
  }
  	motor[rightNonDirect] = motor[rightDirect] = 127;
	motor[leftNonDirect] = motor[leftDirect] = 127;
}

void turnRightDeg(int ticks, int power)
{
  //reset encoders
  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

  //Determine tickGoal
 //int tickGoal = (23 * degrees) / 10;
 int tickGoal = ticks;
  //Start the motors in a left point turn.
  	motor[rightNonDirect] = motor[rightDirect] = power;
	//motor[leftChain] = motor[leftDirect] = -1* power;

  //Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
  //we need to test both encoders and control both motors separately. This may result in one motor
  //going for longer than another but it will ultimately result in a much more accurate turn.
  while(SensorValue[encoderLeft] < tickGoal || SensorValue[encoderRight] > -1 * tickGoal) {
  //	while(SensorValue[EncoderR] <  tickGoal) {
    if(SensorValue[encoderLeft] > tickGoal) {motor[encoderLeft] = 0;}
    if(SensorValue[encoderRight] > tickGoal) {motor[encoderRight] = 0;}
  }
  //Make sure both motors stop at the end of the turn.
	motor[rightNonDirect] = motor[rightDirect] = 0; // Go Forward Full Speed To Mobile Goal
	motor[leftNonDirect] = motor[leftDirect] = 0;
}
void turnLeftDeg(int ticks, int power)
{
  //Reset encoders
  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

  //Determine tickGoal
 // int tickGoal = (23 * degrees) / 10;
 int tickGoal = ticks;
  //Start the motors in a left point turn.
 	motor[rightNonDirect] = motor[rightDirect] = -1*power;
	motor[leftNonDirect] = motor[leftDirect] = power;


  //Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
  //we need to test both encoders and control both motors separately. This may result in one motor
  //going for longer than another but it will ultimately result in a much more accurate turn.
while(SensorValue[encoderLeft] < tickGoal || SensorValue[encoderRight] < -1 * tickGoal) {
//	while(SensorValue[EncoderL] < tickGoal){
    if(SensorValue[encoderLeft] >  tickGoal) {motor[encoderLeft] = 0;}
    if(SensorValue[encoderRight] < -1 * tickGoal) {motor[encoderRight] = 0;}
  }
  //Make sure both motors stop at the end of the turn.
	motor[rightNonDirect] = motor[rightDirect] = 0; // Go Forward Full Speed To Mobile Goal
	motor[leftNonDirect] = motor[leftDirect] = 0;
}
task autonomous()
{
	/*
	motor[TM] = 127; // Lifting Tower Full Speed About Half Way Up
		wait1Msec(750); // For 0.75 Seconds
	motor[TM] = 10; // Keep Motor From Falling Down
	motor[mgmLeft] = motor[mgmRight] = -127; // Lower MGM Full Speed To Pick Up Mobile Goal
		wait1Msec(1000); // For 1 Second
		driveStraightDistance(x,127);
		wait1Msec(100);
			motor[mgmLeft] = motor[mgmRight] = 0; // Stop The MGM Where It Is (Stop It From Going Down)

	motor[mgmLeft] = motor[mgmRight] = 63; // Lift MGM Half Speed With Mobile Goal
		wait1Msec(530); // For 0.53 Seconds
	motor[mgmLeft] = motor[mgmRight] = 0; // Stop The MGM Where It Is (Stop It From Going Up)

		turnLeftDeg(x,127);
		wait1Msec(100);
		driveStraightDistance(x,127);
		wait1Msec(100);
			motor[TM] = -127; // Lower The Tower To Put The Cone On The Mobile Goal
		wait1Msec(250); // For 0.25 Seconds
	motor[TM] = 0; // Stop Tower Motor From Going Down

	motor[Claw] = -127;
		wait1Msec(500); //Stop to drop cone
	motor[Claw] = 0;
	turnLeftDeg(x,127);
	driveStraightDistance(x,127);
			wait1Msec(100);

	motor[mgmLeft] = motor[mgmRight] = -127;
		wait1Msec(500); //Drop mgm
	motor[mgmLeft] = motor[mgmRight] = 0;

	driveStraightDistance(x,127);

	*/
}
task usercontrol()
{
	float KpFourBar = .5;
	float KiFourBar = .5;
	float KdFourBar = .5;
	int errorNowFourBar = 0;
	int errorPreviousFourBar = 0;
	int fourBarEncoderVal = 0;
	int errorOverall = 0;
	float KpChainBar = .5;
	float KiChainBar = .5;
	float KdChainBar = .5;
	int errorNowChainBar = 0;
	int errorPreviousChainBar = 0;
	int ChainBarEncoderVal = 0;
	int errorOverallChainBar = 0;
	nMotorEncoder[chainBar] = 0;
	while (true)
	{
		// ------------------------------------------------------------------------------------------------
		if(abs(vexRT[Ch3]) > 20 || abs(vexRT[Ch4])>20){ // arcade DT code
			motor[leftDirect] = motor[leftNonDirect] = vexRT[Ch3] + vexRT[Ch4];
			motor[rightDirect] = motor[rightNonDirect] = vexRT[Ch3] - vexRT[Ch4];}
		else
			motor[leftDirect] = motor[leftNonDirect] = motor[rightDirect] = motor[rightNonDirect] = 0;
		//-------------------------------------------------------------------------------------------------
		if(vexRT[Btn6D] == 1) //Code to control Mobile Goal Manipulator. Right side Rear buttons.
			motor[mobileGoal] = 127;
		if(vexRT[Btn6U] == 1)
			motor[mobileGoal] = -127;
		if(vexRT[Btn6U]==0 && vexRT[Btn6D] == 0 )
			motor[mobileGoal] = 0;
		//-------------------------------------------------------------------------------------------------
		if(vexRT[Btn5D] == 1)
		{ // code for four bar
			motor[fourBar] = -127;
			fourBarEncoderVal = SensorValue[fourBarEncoder];
		}
		else if(vexRT[Btn5U] == 1)
		{
			motor[fourBar] = 127;
			fourBarEncoderVal = SensorValue[fourBarEncoder];
		}
		else if(vexRT[Btn5D] == 0 && vexRT[Btn5U] == 0)// PID code for four bar
		{
			errorPreviousFourBar = errorNowFourBar;
			errorNowFourBar = fourBarEncoderVal - SensorValue[fourBarEncoder];
			errorOverall = (KpFourBar)*(errorNowFourBar) + (KdFourBar)*((errorNowFourBar - errorPreviousFourBar)/.02);
			if (errorOverall < 0)
				motor[fourBar] = 9;
			else if (errorOverall > 0)
				motor[fourBar] = -9;
			else
				motor[fourBar] = 0;
		}
		//-------------------------------------------------------------------------------------------------
		if ((nMotorEncoder[chainBar]) > 1490){
			if(vexRT[Ch2] > 20){// code for chain bar
				motor[chainBar] = vexRT[Ch2];
				ChainBarEncoderVal = nMotorEncoder[chainBar];}
			else
				motor[chainBar] = 0;}
		else if (abs(vexRT[Ch2]) > 20)
			motor[chainBar] = vexRT[Ch2];
		else
			motor[chainBar] = 0;

		if(abs(vexRT[Ch2])<20)// PID code for chain bar
		{
			errorPreviousChainBar = errorNowChainBar;
			errorNowChainBar = ChainBarEncoderVal - nMotorEncoder[chainBar];
			errorOverallChainBar = (KpChainBar)*(errorNowChainBar) + (KdChainBar)*((errorNowChainBar - errorPreviousChainBar)/.02);
			if (errorOverallChainBar < 0 && nMotorEncoder[chainBar] > 750)
				motor[chainBar] = 9;
			else if (errorOverallChainBar < 0 && nMotorEncoder[chainBar] < 750)
				motor[chainBar] = -9;
			else if (errorOverallChainBar > 0 && nMotorEncoder[chainBar] > 750)
				motor[chainBar] = -9;
			else if (errorOverallChainBar > 0 && nMotorEncoder[chainBar] < 750)
				motor[chainBar] = 9;
			else
				motor[chainBar] = 0;
		}
		//-------------------------------------------------------------------------------------------------
		if(vexRT[Btn6UXmtr2] == 1) // code for roller intake
			motor[claw] = 127;
		if(vexRT[Btn6DXmtr2] == 1)
			motor[claw] = -127;
		if (vexRT[Btn6DXmtr2] == 0 && vexRT[Btn6UXmtr2] ==0)
			motor[claw] = 0;
	}
}

