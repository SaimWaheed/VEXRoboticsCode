#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  chainBarEncoder, sensorQuadEncoder)
#pragma config(Motor,  port2,           leftDirect,    tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftNonDirect, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port4,           rightDirect,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl3)
#pragma config(Motor,  port5,           rightNonDirect, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port6,           mobileGoal,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           fourBar,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           chainBar,      tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl5)
#pragma config(Motor,  port9,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
#pragma platform(VEX2)
#include "VEX_competition_Includes.c"

void stackCone1(){
	if (SensorValue[chainBarEncoder] > 23)
		motor[chainBar] = 127;
	else if (SensorValue[chainBarEncoder] < 18)
		motor[chainBar] = -127;
	else
		motor[chainBar] = 0;
}

void stackCone2(){
	if (SensorValue[chainBarEncoder] > 40)
		motor[chainBar] = 127;
	else if (SensorValue[chainBarEncoder] < 35)
		motor[chainBar] = -127;
	else
		motor[chainBar] = 0;
}

void stackCone3(){
	if (SensorValue[chainBarEncoder] > 55)
		motor[chainBar] = 127;
	else if (SensorValue[chainBarEncoder] < 50)
		motor[chainBar] = -127;
	else
		motor[chainBar] = 0;
}

void stackCone4(){
	if (SensorValue[potentiometer] > 2350)
		motor[fourBar] = 127;
	else if(SensorValue[chainBarEncoder] > 30)
		motor[chainBar] = 127;
	else if(SensorValue[chainBarEncoder] < 20)
		motor[chainBar] = -127;

}

void stackCone6(){
	if (SensorValue[potentiometer] > 2350)
		motor[fourBar] = 127;
	else if(SensorValue[chainBarEncoder] > 40)
		motor[chainBar] = 127;
	else if(SensorValue[chainBarEncoder] < 30)
		motor[chainBar] = -127;
}

void stackCone7(){
	if (SensorValue[potentiometer] > 2600)
		motor[fourBar] = 127;
		//motor[fourBar] = 10;
	else if(SensorValue[chainBarEncoder] > 50)
		motor[chainBar] = 127;
	else if(SensorValue[chainBarEncoder] < 40)
		motor[chainBar] = -127;

}

void stackCone8(){
	if (SensorValue[potentiometer] > 2350)
		motor[fourBar] = 127;
	else if (SensorValue[chainBarEncoder] > 75)
		motor[chainBar] = 127;
	else if (SensorValue[chainBarEncoder] < 65)
		motor[chainBar] = -127;
}

void driveStraightDistance(int ticks, int masterPower)
{
  //int tickGoal = (42 * tenthsOfIn) / 10;
 int tickGoal = ticks;

  //This will count up the total encoder ticks despite the fact that the encoders are constantly reset.
  int totalTicks = 0;

  //Initialise slavePower as masterPower - 5 so we don't get huge error for the first few iterations. The
  //-5 value is based off a rough guess of how much the motors are different, which prevents the robot from
  //veering off course at the start of the function.
  int slavePower = masterPower - 5;

  int error = 0;

  int kp = 5;

  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

  //Monitor 'totalTicks', instead of the values of the encoders which are constantly reset.
  while(totalTicks < tickGoal)
  {
    //Proportional algorithm to keep the robot going straight.
  	motor[rightNonDirect] = motor[rightDirect] = masterPower;
	motor[leftNonDirect] = motor[leftDirect] = slavePower;

    error = SensorValue[encoderLeft] - SensorValue[encoderRight];

    slavePower += error / kp;


  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

    wait1Msec(80);

    //Add this iteration's encoder values to totalTicks.
    totalTicks+= SensorValue[encoderLeft];
  }
  	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;
}

void turnRightDeg(int ticks, int power)
{
  //reset encoders
  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

  //Determine tickGoal
 //int tickGoal = (23 * degrees) / 10;
 int tickGoal = ticks;
  //Start the motors in a left point turn.
  	motor[rightNonDirect] = motor[rightDirect] = power;
	//motor[leftChain] = motor[leftDirect] = -1* power;

  //Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
  //we need to test both encoders and control both motors separately. This may result in one motor
  //going for longer than another but it will ultimately result in a much more accurate turn.
  while(SensorValue[encoderLeft] < tickGoal || SensorValue[encoderRight] > -1 * tickGoal) {
  //	while(SensorValue[EncoderR] <  tickGoal) {
    if(SensorValue[encoderLeft] > tickGoal) {motor[encoderLeft] = 0;}
    if(SensorValue[encoderRight] > tickGoal) {motor[encoderRight] = 0;}
  }
  //Make sure both motors stop at the end of the turn.
	motor[rightNonDirect] = motor[rightDirect] = 0; // Go Forward Full Speed To Mobile Goal
	motor[leftNonDirect] = motor[leftDirect] = 0;
}
void turnLeftDeg(int ticks, int power)
{
  //Reset encoders
  SensorValue[encoderLeft] = 0;
  SensorValue[encoderRight] = 0;

  //Determine tickGoal
 // int tickGoal = (23 * degrees) / 10;
 int tickGoal = ticks;
  //Start the motors in a left point turn.
 	motor[rightNonDirect] = motor[rightDirect] = -1*power;
	motor[leftNonDirect] = motor[leftDirect] = power;


  //Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
  //we need to test both encoders and control both motors separately. This may result in one motor
  //going for longer than another but it will ultimately result in a much more accurate turn.
while(SensorValue[encoderLeft] < tickGoal || SensorValue[encoderRight] > -1 * tickGoal) {
//	while(SensorValue[EncoderL] < tickGoal){
    if(SensorValue[encoderLeft] >  tickGoal) {motor[encoderLeft] = 0;}
    if(SensorValue[encoderRight] < -1 * tickGoal) {motor[encoderRight] = 0;}
  }
  //Make sure both motors stop at the end of the turn.
	motor[rightNonDirect] = motor[rightDirect] = 0; // Go Forward Full Speed To Mobile Goal
	motor[leftNonDirect] = motor[leftDirect] = 0;
}


void pre_auton()
{
	bStopTasksBetweenModes = true; // Pre Autonomous
}



task autonomous()
{
	SensorValue[encoderLeft] = SensorValue[encoderRight] = SensorValue(chainBarEncoder)= 0;

		while(SensorValue[chainBarEncoder] < 44)motor[chainBar] = -127;

		motor[chainBar] = -9;

		while(SensorValue[potentiometer] > 4094)motor[fourBar] = 127;

		motor[fourBar] = 8;

		//driveStraightDistance(100, 50);
	//	driveStraightDistance(1100, 127);
	//	int tickTotal = 0;
	/*while (tickTotal < 500){
//	if (SensorValue(encoderLeft) < 1230)
		motor[leftNonDirect] = motor[leftDirect] = 127;
//	if (SensorValue(encoderRight) < 1230)
		motor[rightNonDirect] = motor[rightDirect] = 127;
			wait1Msec(100);
	tickTotal = (SensorValue(encoderRight) + SensorValue(encoderLeft)) / 2;
	}*/
		while (SensorValue[encoderLeft] < 50 && SensorValue[encoderRight] < 50){
			if(SensorValue[encoderLeft]<50)motor[rightNonDirect] = motor[rightDirect] = 50;
			if(SensorValue[encoderRight]<50)motor[leftNonDirect] = motor[leftDirect] = 50;
}
	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;

	motor[mobileGoal] = 127;
		wait1Msec(750);
		motor[mobileGoal] = 0;

		while (SensorValue[encoderLeft] < 1600 && SensorValue[encoderRight] < 1600){

			if(SensorValue[encoderLeft]<1450)motor[rightNonDirect] = motor[rightDirect] = 90;
			if(SensorValue[encoderRight]<1450)motor[leftNonDirect] = motor[leftDirect] = 100;


}
	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;

		motor[mobileGoal] = -127;
		wait1Msec(1200);
		motor[mobileGoal] = 0;

	//	while(SensorValue[potentiometer] < 4095)
		motor[fourBar] = -127;
		wait1Msec(110);

		//wait1Msec(200);
		motor[fourBar] = 0;
		while(SensorValue[chainBarEncoder] > 23)
		motor[chainBar] = 127;

		motor[chainBar] = 9;

		motor[claw] = -127;
		wait1Msec(500);
		motor[claw] = 0;

		while(SensorValue[chainBarEncoder] < 44)
		motor[chainBar] = -127;

		motor[chainBar] = -9;
				while(SensorValue[potentiometer] > 4094)
		motor[fourBar] = 127;

		//wait1Msec(200);
		motor[fourBar] = 8;
//		tickTotal = 0;
		SensorValue(encoderLeft) = 0;
		SensorValue(encoderRight) = 0;
	/*while (tickTotal < 500){
//	if (SensorValue(encoderLeft) < -1230)
		motor[leftNonDirect] = motor[leftDirect] = -127;
//	if (SensorValue(encoderRight) < -1230)
		motor[rightNonDirect] = motor[rightDirect] = -127;
			wait1Msec(100);
	tickTotal = (SensorValue(encoderRight) + SensorValue(encoderLeft)) / 2;
}*/
//	driveStraightDistance(-1200, -127);

	while (SensorValue[encoderLeft] > -1380){
	motor[rightNonDirect] = motor[rightDirect] = -127;
	motor[leftNonDirect] = motor[leftDirect] = -127;
}
	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;

		SensorValue(encoderLeft) = 0;
		SensorValue(encoderRight) = 0;

/*			while (SensorValue[encoderLeft] < 400 && SensorValue[encoderRight] > -400){
			if(SensorValue[encoderLeft]<400)motor[rightNonDirect] = motor[rightDirect] = 50;
			if(SensorValue[encoderRight]>-400)motor[leftNonDirect] = motor[leftDirect] = -50;
}
	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;*/
	turnLeftDeg(350,50);
	wait1Msec(100);
		while (SensorValue[encoderLeft] < 1000 && SensorValue[encoderRight] < 1000){
			if(SensorValue[encoderLeft]<1000)motor[rightNonDirect] = motor[rightDirect] = 100;
			if(SensorValue[encoderRight]<1000)motor[leftNonDirect] = motor[leftDirect] = 100;
}
		SensorValue(encoderLeft) = 0;
		SensorValue(encoderRight) = 0;
	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;
			wait1Msec(100);
		turnLeftDeg(250,50);
				SensorValue(encoderLeft) = 0;
		SensorValue(encoderRight) = 0;
		wait1Msec(100);
				while (SensorValue[encoderLeft] < 700 && SensorValue[encoderRight] < 700){
			if(SensorValue[encoderLeft]<700)motor[rightNonDirect] = motor[rightDirect] = 127;
			if(SensorValue[encoderRight]<700)motor[leftNonDirect] = motor[leftDirect] = 127;
}
				SensorValue(encoderLeft) = 0;
		SensorValue(encoderRight) = 0;
	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;
	motor[mobileGoal] = 127;
	wait1Msec(1200);
	motor[mobileGoal] = 0;
	while (SensorValue[encoderLeft] > -350 && SensorValue[encoderRight] > -350){
			if(SensorValue[encoderLeft]>-350)motor[rightNonDirect] = motor[rightDirect] = -127;
			if(SensorValue[encoderRight]>-350)motor[leftNonDirect] = motor[leftDirect] = -127;
}
	motor[rightNonDirect] = motor[rightDirect] = 0;
	motor[leftNonDirect] = motor[leftDirect] = 0;

}


task usercontrol()
{
	float Kp = .5, Ki = .5, Kd = .5;
	int fourBarRequested = 0, chainBarRequested = 0;
	int fourBarErrorNow = 0, chainBarErrorNow = 0;
	int fourBarErrorPrevious = 0, chainBarErrorPrevious = 0;
	int fourBarErrorOverall = 0, chainBarErrorOverall = 0;
	motor[fourBar] = 0;
	wait1Msec(50);
	SensorValue[potentiometer] = 0;
	motor[claw] = 0;
	while (true){
		//-----------------------------------------------------------------------------------------
		if(abs(vexRT[Ch3]) > 20 || abs(vexRT[Ch4])>20){ // arcade DT code
			motor[leftDirect] = motor[leftNonDirect] = vexRT[Ch3] + vexRT[Ch4];
			motor[rightDirect] = motor[rightNonDirect] = vexRT[Ch3] - vexRT[Ch4];}
		else
			motor[leftDirect] = motor[leftNonDirect] = motor[rightDirect] = motor[rightNonDirect] = 0;
		//------------------------------------------------------------------------------------------
		if(vexRT[Btn6D] == 1) //Code to control Mobile Goal Manipulator. Right side Rear buttons.
			motor[mobileGoal] = 127;
		if(vexRT[Btn6U] == 1)
			motor[mobileGoal] = -127;
		if(vexRT[Btn6U]==0 && vexRT[Btn6D] == 0 )
			motor[mobileGoal] = 0;
		//--------------------------------------------------------------------------------------------
		if (vexRT[Btn5U] == 1){
			motor[fourBar] = 127;
			fourBarRequested = SensorValue[potentiometer];
		}
		if (vexRT[Btn5D] == 1){
			motor[fourBar] = -127;
			fourBarRequested = SensorValue[potentiometer];
		}
		if (vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0){
			fourBarErrorPrevious = fourBarErrorNow;
			fourBarErrorNow = fourBarRequested - SensorValue[potentiometer];
			fourBarErrorOverall = (Kp)*(fourBarErrorNow) + (Kd)*((fourBarErrorNow - fourBarErrorPrevious)/.02);
			if (fourBarErrorOverall > 0){
				motor[fourBar] = -8;
			}
			if (fourBarErrorOverall < 0){
				motor[fourBar] = 8;
			}
		}
		else{
			motor[fourBar] = 0;
		}
		//------------------------------------------------------------------------------------------------
		if (abs(vexRT[Ch2]) > 20 && SensorValue[chainBarEncoder] < 280 && SensorValue[chainBarEncoder] > -10){
			motor[chainBar] = vexRT[Ch2];
			chainBarRequested = SensorValue[chainBarEncoder];
		}
		else if(abs(vexRT[Ch2])<20){
			chainBarErrorPrevious = chainBarErrorNow;
			chainBarErrorNow = chainBarRequested - SensorValue[chainBarEncoder];
			chainBarErrorOverall = (Kp)*(chainBarErrorNow) + (Kd)*((chainBarErrorNow - chainBarErrorPrevious)/.02);
			if (chainBarErrorOverall < 0)
				motor[chainBar] = 9;
			if (chainBarErrorOverall > 0)
				motor[chainBar] = -9;
		}
		if (SensorValue[chainBarEncoder] > 280 && vexRT[Ch2] > 20)
			motor[chainBar] = vexRT[Ch2];
		if (SensorValue[chainBarEncoder] < -10 && vexRT[Ch2] < -20)
			motor[chainBar] = vexRT[Ch2];
		//-----------------------------------------------------------------------------------------------
		if (vexRT[Btn7LXmtr2] == 1){//pre set stacks
			stackCone1();
			chainBarRequested = SensorValue[chainBarEncoder];
		}
		if (vexRT[Btn7UXmtr2] == 1){
			stackCone2();
			chainBarRequested = SensorValue[chainBarEncoder];
		}
		if (vexRT[Btn7RXmtr2] == 1){
			stackCone3();
			chainBarRequested = SensorValue[chainBarEncoder];
		}
		while (vexRT[Btn7DXmtr2] == 1){
			stackCone4();
			//stackCone4_2();
			chainBarRequested = SensorValue[chainBarEncoder];
			fourBarRequested = SensorValue[potentiometer];
		}
		while (vexRT[Btn8LXmtr2] == 1){
			stackCone4();
			fourBarRequested = SensorValue[chainBarEncoder];
			chainBarRequested = SensorValue[potentiometer];
		}
		while (vexRT[Btn8UXmtr2]){
			stackCone6();
			fourBarRequested = SensorValue[chainBarEncoder];
			chainBarRequested = SensorValue[potentiometer];
		}
		while (vexRT[Btn8RXmtr2]){
			stackCone7();
			fourBarRequested = SensorValue[chainBarEncoder];
			chainBarRequested = SensorValue[potentiometer];
		}
		while (vexRT[Btn8DXmtr2]){
			stackCone8();
			fourBarRequested = SensorValue[chainBarEncoder];
			chainBarRequested = SensorValue[potentiometer];
		}
		//-------------------------------------------------------------------------------------------------
		if(vexRT[Btn6UXmtr2] == 1) // code for roller intake
			motor[claw] = 127;
		if(vexRT[Btn6DXmtr2] == 1)
			motor[claw] = -127;
		if (vexRT[Btn6DXmtr2] == 0 && vexRT[Btn6UXmtr2] ==0)
			motor[claw] = 0;
	}
}
